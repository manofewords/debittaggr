<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8" />
    <title>debittaggr</title>
    <style>
      :root {
        --spacing: 0.5rem;
        --table-border: 1px solid gray;
      }
      body {
        font-family: system-ui, sans-serif;
        margin: calc(2 * var(--spacing));
        padding: 0;
      }
      h1,
      h2 {
        margin: 0;
      }
      h1 {
        font-size: 1.5rem;
      }
      h2 {
        font-size: 1.2rem;
      }
      button,
      input,
      textarea {
        font-size: 0.8rem;
        border: 1px solid #ccc;
        border-radius: 3px;
      }
      input:disabled,
      textarea:disabled,
      input[type="file"] {
        border-style: none;
      }
      aside,
      main,
      section,
      form#splits {
        display: flex;
        flex-direction: column;
        justify-items: stretch;
        gap: var(--spacing);
      }
      aside,
      main,
      section {
        margin: calc(2 * var(--spacing)) 0;
      }
      summary {
        margin-bottom: var(--spacing);
      }
      form,
      fieldset,
      dl {
        display: grid;
        grid-template-columns: 1fr 2fr;
        gap: var(--spacing);
      }
      label {
        overflow: hidden;
        white-space: nowrap;
        text-overflow: ellipsis;
      }
      textarea {
        height: 6rem;
        &:disabled {
          resize: none;
        }
      }
      nav {
        display: flex;
        gap: var(--spacing);
        button {
          width: 100%;
        }
      }
      dl,
      dd {
        margin: 0;
      }
      ul {
        margin: 0;
        padding: 0;
        list-style-type: none;
      }
      fieldset {
        border: 1px dotted #999;
        padding: var(--spacing);
        margin: 0;
      }
      .graph {
        overflow: scroll;
      }
      svg {
        position: relative;
        rect {
          fill: green;
          opacity: 0.9;
        }
        line {
          stroke: grey;
          stroke-width: 1;
          stroke-dasharray: 5;
        }
        text {
          font-size: 12px;
        }
      }
      table {
        border-collapse: collapse;
      }
      th,
      td {
        border: var(--table-border);
        padding: 0.25rem;
      }
      th {
        text-align: left;
        border-bottom-width: 2px;
      }
    </style>
  </head>
  <body>
    <aside>
      <h1>Data management</h1>
      <form>
        <label for="existing-data">Import existing</label>
        <input
          type="file"
          id="existing-data"
          name="existing-data"
          accept=".json"
        />
        <label for="new-data">Import new</label>
        <input type="file" id="new-data" name="new-data" accept=".csv" />
      </form>
      <button type="button" onclick="exportToJsonFile()">Export</button>
    </aside>
    <main id="debit">
      <h1>Debit</h1>
      <form>
        <label for="description">Description</label>
        <textarea id="description" name="description" disabled></textarea>
        <label for="amount">Amount</label>
        <input id="amount" name="amount" type="text" disabled />
        <label for="currency">Currency</label>
        <input id="currency" name="currency" type="text" disabled />
        <label for="date">Date</label>
        <input id="date" name="date" type="text" disabled />
      </form>
      <section>
        <h2>Splits</h2>
        <form id="splits"></form>
        <button type="button" onclick="addSplit()">Add split</button>
      </section>
      <nav>
        <button type="button" onclick="loadDebitAtIndex(-10)">«</button>
        <button type="button" onclick="loadDebitAtIndex(-1)">‹</button>
        <button type="button" onclick="loadDebitAtIndex(1)">›</button>
        <button type="button" onclick="loadDebitAtIndex(10)">»</button>
      </nav>
    </main>
    <aside id="statistics">
      <h1>Overall statistics</h1>
      <dl>
        <dt>Start date</dt>
        <dd id="start-date"></dd>
        <dt>End date</dt>
        <dd id="end-date"></dd>
        <dt>Number of debits</dt>
        <dd id="debits-count"></dd>
        <dt>Number of splits</dt>
        <dd id="splits-count"></dd>
        <dt>Splits per debit</dt>
        <dd id="splits-per-debit"></dd>
        <dt>Tags</dt>
        <dd>
          <details>
            <summary>Counts</summary>
            <dl id="tag-counts"></dl>
          </details>
        </dd>
      </dl>
    </aside>
    <aside id="by-tag">
      <h1>By tag</h1>
      <form>
        <label for="tag">Tag</label>
        <select
          id="tag"
          name="tag"
          onchange="drawTagGraphAndStatistics(this.value)"
        ></select>
      </form>
      <section>
        <h2>Monthly averages</h2>
        <table id="monthly-averages">
          <thead>
            <tr>
              <th>Year</th>
              <th>Monthly average</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </section>
      <section class="graph">
        <h2>Monthly graph</h2>
        <svg id="monthly-tag-graph">
          <defs>
            <rect><title></title></rect>
            <g class="y-axis">
              <line />
              <text />
            </g>
            <g class="x-axis">
              <line />
              <text />
            </g>
          </defs>
        </svg>
      </section>
      <section class="graph">
        <h2>Daily graph</h2>
        <svg id="daily-tag-graph">
          <defs>
            <rect><title></title></rect>
            <g class="y-axis">
              <line />
              <text />
            </g>
            <g class="x-axis">
              <line />
              <text />
            </g>
          </defs>
        </svg>
      </section>
    </aside>
    <template id="split">
      <fieldset>
        <label for="split-n-amount">Amount</label>
        <input id="split-n-amount" name="split-n-amount" type="text" />
        <label for="split-n-notes">Notes</label>
        <textarea id="split-n-notes" name="split-n-notes"></textarea>
        <label>Tags</label>
        <ul id="split-n-tags">
          <li><input name="split-n-new-tags" type="text" /></li>
        </ul>
        <button type="button">Delete</button>
      </fieldset>
    </template>
    <template id="split-tag">
      <li>
        <input type="checkbox" />
        <label />
      </li>
    </template>
    <template id="term-details">
      <dt></dt>
      <dd></dd>
    </template>
    <template id="tag-option">
      <option></option>
    </template>
    <template id="monthly-table-row">
      <tr>
        <td></td>
        <td></td>
      </tr>
    </template>
    <script>
      const MILLISECONDS_PER_DAY = 24 * 60 * 60 * 1000;
      const CENTS_IN_ONE_CHF = 100;

      const appState = {
        // {
        //   description: string, // usually containing newlines \n
        //   date: string, // "2004-09-23"
        //   amount: string, // "12340" in cents
        //   currency: string, // "CHF"
        //   splits: {
        //     notes: string,
        //     amount: string, // "12340" in cents
        //     tags: string[] // ["FOOD", "RENT"]
        //   }[]
        // }
        debits: [],
        tags: new Set(), // of string
        currentIndex: -1,
        tagCounts: {}, // { tag: string, count: number }
      };

      function readAppState(key) {
        return appState[key];
      }

      function updateAppState(key, value) {
        appState[key] = value;

        appState.tagCounts = Object.values(
          appState.debits.reduce((tagCounts, debit) => {
            for (const split of debit.splits) {
              for (const tag of split.tags) {
                if (tagCounts[tag]) {
                  tagCounts[tag].count += 1;
                } else {
                  tagCounts[tag] = { tag, count: 1 };
                }
              }
            }
            return tagCounts;
          }, {})
        ).sort((a, b) => b.count - a.count);

        updateAndDisplayOverallStatistics(appState.debits, appState.tagCounts);
        updateTagSelector(appState.tagCounts);
      }

      function sortByDate(a, b) {
        if (a.date < b.date) {
          return -1;
        } else if (a.date > b.date) {
          return 1;
        }
        return 0;
      }

      function updateTagSelector(tagCounts) {
        const select = document.querySelector("#tag");
        select.textContent = "";

        const tagOptionTemplate = document.querySelector("#tag-option");

        for (const tagCount of tagCounts) {
          const tagOptionClone = tagOptionTemplate.content.cloneNode(true);
          const option = tagOptionClone.querySelector("option");
          option.textContent = tagCount.tag;
          option.setAttribute("value", tagCount.tag);

          select.appendChild(tagOptionClone);
        }

        drawTagGraphAndStatistics(tagCounts[0].tag);
      }

      function updateAndDisplayOverallStatistics(debits, tagCounts) {
        const debitsCount = debits.length;
        const splitsCount = debits.reduce((splitsCount, debit) => {
          splitsCount += debit.splits.length;
          return splitsCount;
        }, 0);

        document.querySelector("#start-date").textContent =
          debitsCount > 0 ? debits[0].date : "";

        document.querySelector("#end-date").textContent =
          debitsCount > 1 ? debits[debitsCount - 1].date : "";

        document.querySelector("#debits-count").textContent = debitsCount;

        document.querySelector("#splits-count").textContent = splitsCount;

        document.querySelector("#splits-per-debit").textContent =
          Math.round((splitsCount / debitsCount) * CENTS_IN_ONE_CHF) /
          CENTS_IN_ONE_CHF;

        const tagCountsContainer = document.querySelector("#tag-counts");
        tagCountsContainer.textContent = "";
        const termDetailsTemplate = document.querySelector("#term-details");
        for (const tagCount of tagCounts) {
          const termDetailsClone = termDetailsTemplate.content.cloneNode(true);
          termDetailsClone.querySelector("dt").textContent = tagCount.tag;
          termDetailsClone.querySelector("dd").textContent = tagCount.count;
          tagCountsContainer.appendChild(termDetailsClone);
        }
      }

      function drawTagGraphAndStatistics(tag) {
        const debits = readAppState("debits");

        const splits = Object.values(
          debits.reduce((splits, debit) => {
            for (const split of debit.splits) {
              if (split.tags.includes(tag)) {
                if (splits[debit.date]) {
                  splits[debit.date].amount += Number(split.amount);
                  if (split.notes) {
                    splits[debit.date].notes.push(split.notes);
                  }
                } else {
                  splits[debit.date] = {
                    date: debit.date,
                    amount: Number(split.amount),
                    notes: split.notes ? [split.notes] : [],
                  };
                }
              }
            }
            return splits;
          }, {})
        ).sort(sortByDate);

        let svg = document.querySelector("#monthly-tag-graph");
        drawMonthlyTagGraphAndStatistics(svg, debits, splits);

        svg = document.querySelector("#daily-tag-graph");
        drawTagGraph(svg, splits);
      }

      function drawMonthlyTagGraphAndStatistics(svg, debits, splits) {
        if (debits.length < 2 || splits.length < 2) {
          return;
        }

        const startDate = debits[0].date;
        const endDate = debits[debits.length - 1].date;

        const startYear = Number(startDate.substring(0, 4));
        const endYear = Number(endDate.substring(0, 4));

        const monthlySplitsMap = {};
        for (let i = 0; i <= endYear - startYear; i += 1) {
          for (let j = 1; j < 13; j += 1) {
            const month = `${startYear + i}-${String(j).padStart(2, "0")}`;
            monthlySplitsMap[month] = {
              date: month,
              amount: 0,
            };
          }
        }
        for (const split of splits) {
          const month = split.date.substring(0, 7);
          monthlySplitsMap[month].amount += split.amount;
        }
        const monthlySplits = Object.values(monthlySplitsMap);

        drawTagGraph(svg, monthlySplits);

        drawMonthlyTagStatistics(monthlySplits);
      }

      function drawMonthlyTagStatistics(splits) {
        const monthlyAveragesByYear = Object.values(
          splits.reduce((monthlyAveragesByYear, split) => {
            const year = split.date.substring(0, 4);
            if (monthlyAveragesByYear[year]) {
              monthlyAveragesByYear[year].amount += split.amount;
            } else {
              monthlyAveragesByYear[year] = {
                year,
                amount: split.amount,
              };
            }
            return monthlyAveragesByYear;
          }, {})
        );

        const tableBody = document.querySelector(
          "table#monthly-averages > tbody"
        );
        tableBody.innerHTML = "";

        const monthlyTableRowTemplate =
          document.querySelector("#monthly-table-row");

        for (const monthlyAverageByYear of monthlyAveragesByYear) {
          const monthlyTableRowClone =
            monthlyTableRowTemplate.content.cloneNode(true);

          const cells = monthlyTableRowClone.querySelectorAll("td");
          cells[0].textContent = monthlyAverageByYear.year;
          cells[1].textContent = Math.round(
            monthlyAverageByYear.amount / CENTS_IN_ONE_CHF / 12
          );

          tableBody.appendChild(monthlyTableRowClone);
        }
      }

      function drawTagGraph(svg, splits) {
        if (!svg || splits.length < 2) {
          return;
        }

        const GRAPH_BAR_WIDTH_IN_PIXELS = 5;
        const CENTS_HEIGHT_IN_PIXELS = 0.01; // 1 CHF = 1 pixel
        const AXIS_TEXT_MARGIN_IN_PIXELS = 2;
        const AXIS_TEXT_SIZE_IN_PIXELS = 12; // SVG text size in CSS

        let startDate = splits[0].date;

        let dateToPixels;
        let svgWidth;
        let xAxisLabels;
        let yAxisResolutionInCHF;
        if (startDate.length === 10) {
          // daily mode: splits is a sparse list, i.e. there are days for which there is no split in splits

          let endDate = splits[splits.length - 1].date;

          const startTimestamp = Date.parse(startDate);
          const endTimestamp = Date.parse(endDate);

          function timestampToPixels(timestamp) {
            return (
              (timestamp / MILLISECONDS_PER_DAY) * GRAPH_BAR_WIDTH_IN_PIXELS
            );
          }

          svgWidth =
            timestampToPixels(endTimestamp - startTimestamp) +
            GRAPH_BAR_WIDTH_IN_PIXELS;

          xAxisLabels = splits.reduce((xAxisLabels, split) => {
            xAxisLabels.add(split.date.substring(0, 7));
            return xAxisLabels;
          }, new Set());

          yAxisResolutionInCHF = 50;

          dateToPixels = (index, date) =>
            timestampToPixels(Date.parse(date) - startTimestamp);
        } else if (startDate.length === 7) {
          // monthly mode: there is a split in splits for each month

          svgWidth = splits.length * GRAPH_BAR_WIDTH_IN_PIXELS;

          xAxisLabels = splits.reduce((xAxisLabels, split) => {
            xAxisLabels.add(split.date.substring(0, 4));
            return xAxisLabels;
          }, new Set());

          yAxisResolutionInCHF = 100;

          dateToPixels = (index, date) => index * GRAPH_BAR_WIDTH_IN_PIXELS;
        } else {
          return;
        }

        function amountToPixels(amount) {
          return amount * CENTS_HEIGHT_IN_PIXELS;
        }

        const maxAmount = splits.reduce((maxAmount, split) => {
          if (split.amount > maxAmount) {
            maxAmount = split.amount;
          }
          return maxAmount;
        }, 0);

        const svgHeight =
          amountToPixels(maxAmount) +
          (AXIS_TEXT_SIZE_IN_PIXELS + AXIS_TEXT_MARGIN_IN_PIXELS);

        svg.setAttribute("width", svgWidth);
        svg.setAttribute("height", svgHeight);
        svg.style.width = svgWidth + "px";
        svg.style.height = svgHeight + "px";

        svg.querySelectorAll("& > g.x-axis").forEach((g) => svg.removeChild(g));
        const labels = Array.from(xAxisLabels);
        for (let i = 0; i < labels.length; i += 1) {
          const label = labels[i];

          const g = svg.querySelector("defs > g.x-axis").cloneNode(true);

          const x = dateToPixels(i * 12, `${label}-01`);

          const line = g.querySelector("line");
          line.setAttribute("x1", x);
          line.setAttribute("y1", amountToPixels(maxAmount));
          line.setAttribute("x2", x);
          line.setAttribute(
            "y2",
            amountToPixels(maxAmount) + AXIS_TEXT_MARGIN_IN_PIXELS
          );

          const text = g.querySelector("text");
          text.setAttribute("x", x);
          text.setAttribute(
            "y",
            amountToPixels(maxAmount) +
              AXIS_TEXT_SIZE_IN_PIXELS +
              AXIS_TEXT_MARGIN_IN_PIXELS
          );
          text.textContent = label;

          svg.appendChild(g);
        }

        svg.querySelectorAll("& > g.y-axis").forEach((g) => svg.removeChild(g));
        for (
          let i = 1;
          i < Math.ceil(maxAmount / (yAxisResolutionInCHF * CENTS_IN_ONE_CHF));
          i += 1
        ) {
          const g = svg.querySelector("defs > g.y-axis").cloneNode(true);

          const y = amountToPixels(
            maxAmount - i * (yAxisResolutionInCHF * CENTS_IN_ONE_CHF)
          );

          const line = g.querySelector("line");
          line.setAttribute("x1", 0);
          line.setAttribute("y1", y);
          line.setAttribute("x2", svgWidth);
          line.setAttribute("y2", y);

          const text = g.querySelector("text");
          text.setAttribute("x", 0);
          text.setAttribute("y", y - AXIS_TEXT_MARGIN_IN_PIXELS);
          text.textContent = i * yAxisResolutionInCHF;

          svg.appendChild(g);
        }

        svg
          .querySelectorAll("& > rect")
          .forEach((rect) => svg.removeChild(rect));
        for (let i = 0; i < splits.length; i += 1) {
          const split = splits[i];

          const x = dateToPixels(i, split.date);
          const y = amountToPixels(maxAmount - split.amount);
          const width = GRAPH_BAR_WIDTH_IN_PIXELS;
          const height = amountToPixels(split.amount);

          const rect = svg.querySelector("defs > rect").cloneNode(true);

          rect.setAttribute("x", x);
          rect.setAttribute("y", y);
          rect.setAttribute("width", width);
          rect.setAttribute("height", height);

          rect.querySelector("title").textContent =
            split.amount / CENTS_IN_ONE_CHF +
            (split.notes?.length ? " = " + split.notes.join(" + ") : "");

          svg.appendChild(rect);
        }
      }

      function readExistingData(file, onFileRead) {
        const fileReader = new FileReader();

        fileReader.addEventListener("load", (event) => {
          try {
            const existingData = JSON.parse(event.target.result);
            onFileRead(existingData);
          } catch (error) {
            console.error(error);
          }
        });

        fileReader.readAsText(file);
      }

      function readNewData(file, onFileRead) {
        const fileReader = new FileReader();

        fileReader.addEventListener("load", (event) => {
          try {
            const newData = csvToDebit(event.target.result);
            onFileRead(newData);
          } catch (error) {
            console.error(error);
          }
        });

        fileReader.readAsText(file);
      }

      function exportToJsonFile() {
        const debits = readAppState("debits");
        const filename = "debittaggr.json";
        const href = `data:text/json;charset=utf-8,${encodeURIComponent(
          JSON.stringify(debits, null, 2)
        )}`;
        const temporaryElement = document.createElement("a");
        temporaryElement.setAttribute("href", href);
        temporaryElement.setAttribute("download", filename);
        temporaryElement.click();
        temporaryElement.remove();
      }

      function csvToDebit(fileContents) {
        const delimiter = ";";
        const newLine = "\n";

        const rows = fileContents
          .slice(fileContents.indexOf(newLine) + 1)
          .split(newLine);

        return rows
          .map((row) => {
            const values = row.split(delimiter);
            if (values.length !== 21) {
              return null;
            }
            const amount = values[18].replaceAll("'", "").replaceAll(".", "");
            if (amount === "") {
              return null;
            }
            const [day, month, year] = values[9].split(".");
            return {
              amount,
              description: [values[8], values[12], values[13], values[14]].join(
                " "
              ),
              date: [year, month, day].join("-"),
              currency: values[5],
              splits: [],
            };
          })
          .filter((row) => {
            return row !== null;
          });
      }

      function loadSplitIntoForm(debit, index, tags, split) {
        const splitTemplate = document.querySelector("#split");
        const splitClone = splitTemplate.content.cloneNode(true);

        splitClone
          .querySelector("fieldset")
          .setAttribute("id", `split-${index}`);

        let identifier = `split-${index}-amount`;

        splitClone
          .querySelector('label[for="split-n-amount"]')
          .setAttribute("for", identifier);

        const amountInput = splitClone.querySelector(
          'input[name="split-n-amount"]'
        );
        amountInput.setAttribute("id", identifier);
        amountInput.setAttribute("name", identifier);
        amountInput.value = split.amount;
        amountInput.addEventListener("input", (event) => {
          split.amount = event.target.value;
        });

        identifier = `split-${index}-notes`;

        splitClone
          .querySelector('label[for="split-n-notes"]')
          .setAttribute("for", identifier);

        const notesInput = splitClone.querySelector(
          'textarea[name="split-n-notes"]'
        );
        notesInput.setAttribute("id", identifier);
        notesInput.setAttribute("name", identifier);
        notesInput.value = split.notes;
        notesInput.addEventListener("input", (event) => {
          split.notes = event.target.value;
        });

        const tagsContainer = splitClone.querySelector("#split-n-tags");
        tagsContainer.setAttribute("id", `split-${index}-tags`);
        for (const tag of tags) {
          const tagTemplate = document.querySelector("#split-tag");
          const tagClone = tagTemplate.content.cloneNode(true);

          identifier = `split-${index}-${tag}`;

          const tagCheckbox = tagClone.querySelector("input");
          tagCheckbox.setAttribute("id", identifier);
          tagCheckbox.setAttribute("name", identifier);
          tagCheckbox.setAttribute("data-tag", tag);
          tagCheckbox.checked = split.tags.includes(tag);
          tagCheckbox.addEventListener("input", (event) => {
            const { tag } = event.target.dataset;
            if (event.target.checked) {
              split.tags.push(tag);
            } else {
              split.tags = split.tags.filter((splitTag) => splitTag !== tag);
            }
          });

          const tagLabel = tagClone.querySelector("label");
          tagLabel.setAttribute("for", identifier);
          tagLabel.textContent = tag;

          tagsContainer.appendChild(tagClone);
        }

        const newTagsInput = tagsContainer.querySelector(
          'input[name="split-n-new-tags"]'
        );
        newTagsInput.setAttribute("name", `split-${index}-new-tags`);
        newTagsInput.addEventListener("blur", (event) => {
          const newTags = event.target.value.toUpperCase().split(" ");
          for (const newTag of newTags) {
            if (!split.tags.includes(newTag)) {
              split.tags.push(newTag);
            }
            if (!tags.has(newTag)) {
              tags.add(newTag);
              updateAppState("tags", tags);
            }
          }
        });

        splitClone.querySelector("button").onclick = () => {
          debit.splits.splice(index, 1);
          loadSplitsIntoForm(debit, tags);
        };

        document.querySelector("#splits").appendChild(splitClone);
      }

      function loadSplitsIntoForm(debit, tags) {
        document.querySelector("#splits").innerHTML = "";

        if (debit.splits.length === 0) {
          addSplit();
        } else {
          for (let i = 0; i < debit.splits.length; i += 1) {
            loadSplitIntoForm(debit, i, tags, debit.splits[i]);
          }
        }
      }

      function loadDebitIntoForm(debit, tags) {
        document.querySelector('textarea[name="description"]').value =
          debit.description;
        document.querySelector('input[name="amount"]').value = debit.amount;
        document.querySelector('input[name="currency"]').value = debit.currency;
        document.querySelector('input[name="date"]').value = debit.date;

        loadSplitsIntoForm(debit, tags);
      }

      function loadDebitAtIndex(offset) {
        const debits = readAppState("debits");
        const tags = readAppState("tags");
        const currentIndex = readAppState("currentIndex");
        const index = (currentIndex + offset) % debits.length;

        updateAppState("currentIndex", index);

        loadDebitIntoForm(debits[index], tags);
      }

      function load(debits) {
        if (debits.length === 0) {
          document.querySelector("#debit").style.display = "none";
          document.querySelector("#statistics").style.display = "none";
          document.querySelector("#by-tag").style.display = "none";
          return;
        }
        document.querySelector("#debit").style.display = "flex";
        document.querySelector("#statistics").style.display = "flex";
        document.querySelector("#by-tag").style.display = "flex";

        const tags = debits.reduce((tags, debit) => {
          for (const split of debit.splits) {
            for (const tag of split.tags) {
              tags.add(tag);
            }
          }
          return tags;
        }, new Set());

        updateAppState("tags", tags);

        const sortedDebits = debits.sort(sortByDate);

        let index = sortedDebits.findIndex(
          (debit) => debit.splits.length === 0
        );
        if (index === -1) {
          index = 0;
        }

        updateAppState("currentIndex", index);

        loadDebitIntoForm(debits[index], tags);
      }

      function addSplit() {
        const debits = readAppState("debits");
        const index = readAppState("currentIndex");
        const tags = readAppState("tags");

        const debit = debits[index];

        const split = {
          amount: String(
            debit.amount -
              debit.splits.reduce((splitAmount, split) => {
                splitAmount += Number(split.amount);
                return splitAmount;
              }, 0)
          ),
          notes: "",
          tags: [],
        };

        debit.splits.push(split);

        loadSplitIntoForm(debit, debit.splits.length - 1, tags, split);
      }

      const existingDataFileSelector = document.querySelector(
        'input[name="existing-data"]'
      );
      existingDataFileSelector.addEventListener("change", (event) => {
        readExistingData(event.target.files[0], (data) => {
          const debits = [...readAppState("debits"), ...data];
          updateAppState("debits", debits);
          load(debits);
        });
      });

      const newDataFileSelector = document.querySelector(
        'input[name="new-data"]'
      );
      newDataFileSelector.addEventListener("change", (event) => {
        readNewData(event.target.files[0], (data) => {
          const debits = [...readAppState("debits"), ...data];
          updateAppState("debits", debits);
          load(debits);
        });
      });

      load(readAppState("debits"));
    </script>
  </body>
</html>
