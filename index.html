<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>debittaggr</title>
    <style>
      :root {
        --spacing: 0.5rem;
        --table-border: 1px solid gray;
      }
      body {
        font-family: system-ui, sans-serif;
        margin: calc(2 * var(--spacing));
        padding: 0;
      }
      h1,
      h2 {
        margin: 0;
      }
      h1 {
        font-size: 1.5rem;
      }
      h2 {
        font-size: 1.2rem;
      }
      button,
      input,
      textarea {
        font-size: 0.8rem;
        border: 1px solid #ccc;
        border-radius: 3px;
      }
      input:disabled,
      textarea:disabled,
      input[type="file"] {
        border-style: none;
      }
      aside,
      main,
      section,
      form#splits {
        display: flex;
        flex-direction: column;
        justify-items: stretch;
        gap: var(--spacing);
      }
      aside,
      main,
      section {
        margin: calc(2 * var(--spacing)) 0;
      }
      summary {
        margin-bottom: var(--spacing);
      }
      form,
      fieldset,
      dl {
        display: grid;
        grid-template-columns: 1fr 2fr;
        gap: var(--spacing);
      }
      label {
        overflow: hidden;
        white-space: nowrap;
        text-overflow: ellipsis;
      }
      textarea {
        height: 6rem;
        &:disabled {
          resize: none;
        }
      }
      nav {
        display: flex;
        gap: var(--spacing);
        button {
          width: 100%;
        }
      }
      dl,
      dd {
        margin: 0;
      }
      ul {
        margin: 0;
        padding: 0;
        list-style-type: none;
      }
      fieldset {
        border: 1px dotted #999;
        padding: var(--spacing);
        margin: 0;
      }
      .graph {
        overflow: scroll;
      }
      svg {
        position: relative;
        rect {
          fill: green;
          opacity: 0.9;
        }
        line {
          stroke: grey;
          stroke-width: 1;
          stroke-dasharray: 5;
        }
        text {
          font-size: 12px;
        }
      }
      table {
        border-collapse: collapse;
      }
      th,
      td {
        border: var(--table-border);
        padding: 0.25rem;
      }
      th {
        text-align: left;
        border-bottom-width: 2px;
      }
    </style>
  </head>
  <body>
    <aside>
      <h1>Data management</h1>
      <form>
        <label for="existing-data">Import existing</label>
        <input
          type="file"
          id="existing-data"
          name="existing-data"
          accept=".json"
        />
        <label for="new-data">Import new</label>
        <input type="file" id="new-data" name="new-data" accept=".csv" />
      </form>
      <button type="button" onclick="exportToJsonFile()">Export</button>
    </aside>
    <main id="debit">
      <h1>Debit</h1>
      <form>
        <label for="description">Description</label>
        <textarea id="description" name="description" disabled></textarea>
        <label for="amount">Amount</label>
        <input id="amount" name="amount" type="text" disabled />
        <label for="currency">Currency</label>
        <input id="currency" name="currency" type="text" disabled />
        <label for="date">Date</label>
        <input id="date" name="date" type="text" disabled />
      </form>
      <section>
        <h2>Splits</h2>
        <form id="splits"></form>
        <button type="button" onclick="addSplit()">Add split</button>
      </section>
      <nav>
        <button type="button" onclick="loadDebitAtIndex(-10)">«</button>
        <button type="button" onclick="loadDebitAtIndex(-1)">‹</button>
        <button type="button" onclick="loadDebitAtIndex(1)">›</button>
        <button type="button" onclick="loadDebitAtIndex(10)">»</button>
      </nav>
    </main>
    <aside id="statistics">
      <h1>Overall statistics</h1>
      <dl>
        <dt>Start date</dt>
        <dd id="start-date"></dd>
        <dt>End date</dt>
        <dd id="end-date"></dd>
        <dt>Number of debits</dt>
        <dd id="debits-count"></dd>
        <dt>Number of splits</dt>
        <dd id="splits-count"></dd>
        <dt>Splits per debit</dt>
        <dd id="splits-per-debit"></dd>
        <dt>Tags</dt>
        <dd>
          <details>
            <summary>Counts</summary>
            <dl id="tag-counts"></dl>
          </details>
        </dd>
      </dl>
    </aside>
    <aside id="by-tags">
      <h1>By tags</h1>
      <form>
        <label for="tags">Tags</label>
        <select
          id="tags"
          name="tags"
          multiple
          onchange="drawTagsGraphAndStatistics(this.selectedOptions)"
        ></select>
      </form>
      <section>
        <h2>Monthly averages</h2>
        <table id="monthly-averages">
          <thead>
            <tr>
              <th>Year</th>
              <th>Monthly average</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </section>
      <section class="graph">
        <h2>Monthly graph</h2>
        <svg id="monthly-tags-graph">
          <defs>
            <rect><title></title></rect>
            <g class="y-axis">
              <line />
              <text />
            </g>
            <g class="x-axis">
              <line />
              <text />
            </g>
          </defs>
        </svg>
      </section>
      <section class="graph">
        <h2>Daily graph</h2>
        <svg id="daily-tags-graph">
          <defs>
            <rect><title></title></rect>
            <g class="y-axis">
              <line />
              <text />
            </g>
            <g class="x-axis">
              <line />
              <text />
            </g>
          </defs>
        </svg>
      </section>
    </aside>
    <template id="split">
      <fieldset>
        <label for="split-n-amount">Amount</label>
        <input id="split-n-amount" name="split-n-amount" type="text" />
        <label for="split-n-notes">Notes</label>
        <textarea id="split-n-notes" name="split-n-notes"></textarea>
        <label>Tags</label>
        <ul id="split-n-tags">
          <li><input name="split-n-new-tags" type="text" /></li>
        </ul>
        <button type="button">Delete</button>
      </fieldset>
    </template>
    <template id="split-tag">
      <li>
        <input type="checkbox" />
        <label />
      </li>
    </template>
    <template id="term-details">
      <dt></dt>
      <dd></dd>
    </template>
    <template id="tag-option">
      <option></option>
    </template>
    <template id="monthly-table-row">
      <tr>
        <td></td>
        <td></td>
      </tr>
    </template>
    <script>
      const MILLISECONDS_PER_DAY = 24 * 60 * 60 * 1000;
      const CENTS_IN_ONE_CHF = 100;

      const appState = {
        // {
        //   description: string, // usually containing newlines \n
        //   date: string, // "2004-09-23"
        //   amount: string, // "12340", in cents
        //   currency: string, // "CHF"
        //   splits: {
        //     notes: string,
        //     amount: string, // "12340", in cents
        //     tags: string[] // ["FOOD", "RENT"]
        //   }[]
        // }
        debits: [],
        tags: new Set(), // ["FOOD", "RENT"]
        currentIndex: -1,
        tagCounts: [], // { tag: string, count: number }
      };

      function readAppState(key) {
        return appState[key];
      }

      function updateAppState(key, value) {
        appState[key] = value;

        // count usage of each tag in the debit splits
        appState.tagCounts = Object.values(
          appState.debits.reduce((tagCounts, debit) => {
            for (const split of debit.splits) {
              for (const tag of split.tags) {
                if (tagCounts[tag]) {
                  tagCounts[tag].count += 1;
                } else {
                  tagCounts[tag] = { tag, count: 1 };
                }
              }
            }
            return tagCounts;
          }, {})
        ).sort((a, b) => b.count - a.count);

        appState.tags = new Set(appState.tagCounts.map(({ tag }) => tag));

        updateAndDisplayOverallStatistics(appState.debits, appState.tagCounts);

        updateTagSelector(appState.tagCounts);
      }

      function sortByAscendingDate(a, b) {
        if (a.date < b.date) {
          return -1;
        } else if (a.date > b.date) {
          return 1;
        }
        return 0;
      }

      function updateTagSelector(tagCounts) {
        // clear <select>'s <option>s
        const select = document.querySelector("#tags");
        select.textContent = "";

        const tagOptionTemplate = document.querySelector("#tag-option");

        // create <select>'s <option>s
        for (let i = 0; i < tagCounts.length; i += 1) {
          const tagOptionClone = tagOptionTemplate.content.cloneNode(true);

          const option = tagOptionClone.querySelector("option");
          option.textContent = tagCounts[i].tag;
          option.setAttribute("value", tagCounts[i].tag);
          if (i === 0) {
            option.setAttribute("selected", "selected");
          }

          select.appendChild(tagOptionClone);
        }

        // show graph and statistics of most used tag by default
        drawTagsGraphAndStatistics([{ value: tagCounts[0].tag }]);
      }

      function updateAndDisplayOverallStatistics(debits, tagCounts) {
        const debitsCount = debits.length;
        const splitsCount = debits.reduce((splitsCount, debit) => {
          splitsCount += debit.splits.length;
          return splitsCount;
        }, 0);

        document.querySelector("#start-date").textContent =
          debitsCount > 0 ? debits[0].date : "";

        document.querySelector("#end-date").textContent =
          debitsCount > 1 ? debits[debitsCount - 1].date : "";

        document.querySelector("#debits-count").textContent = debitsCount;

        document.querySelector("#splits-count").textContent = splitsCount;

        document.querySelector("#splits-per-debit").textContent =
          Math.round((splitsCount / debitsCount) * CENTS_IN_ONE_CHF) /
          CENTS_IN_ONE_CHF;

        const tagCountsContainer = document.querySelector("#tag-counts");
        tagCountsContainer.textContent = "";
        const termDetailsTemplate = document.querySelector("#term-details");
        for (const tagCount of tagCounts) {
          const termDetailsClone = termDetailsTemplate.content.cloneNode(true);
          termDetailsClone.querySelector("dt").textContent = tagCount.tag;
          termDetailsClone.querySelector("dd").textContent = tagCount.count;
          tagCountsContainer.appendChild(termDetailsClone);
        }
      }

      function drawTagsGraphAndStatistics(selectedTags) {
        const tags = Array.from(selectedTags).map(({ value }) => value);
        const debits = readAppState("debits");

        const startTimestamp = Date.parse(debits[0].date);
        const endTimestamp = Date.parse(debits[debits.length - 1].date);
        const daysCount =
          (endTimestamp - startTimestamp) / MILLISECONDS_PER_DAY;

        const splitsMap = {};
        for (let i = 0; i <= daysCount; i += 1) {
          const date = new Date(startTimestamp + i * MILLISECONDS_PER_DAY)
            .toISOString()
            .substring(0, 10);
          splitsMap[date] = {
            date,
            amount: 0,
            notes: [],
          };
        }
        for (const debit of debits) {
          for (const split of debit.splits) {
            const splitIncludesTags =
              split.tags.length > 0 &&
              split.tags.every((splitTag) => tags.includes(splitTag));
            if (splitIncludesTags) {
              splitsMap[debit.date].amount += Number(split.amount);
              if (split.notes) {
                splitsMap[debit.date].notes.push(split.notes);
              }
            }
          }
        }
        // all the splits for the given tags:
        // {
        //   date: string, // "2023-04-11"
        //   amount: number, // in cents
        //   notes: string[] // ["note 1", "note 2"]
        // }[]
        const splits = Object.values(splitsMap);

        let svg = document.querySelector("#monthly-tags-graph");
        drawMonthlyTagsGraphAndStatistics(svg, splits);

        svg = document.querySelector("#daily-tags-graph");
        drawTagsGraph(svg, splits);
      }

      function drawMonthlyTagsGraphAndStatistics(svg, splits) {
        if (splits.length < 1) {
          return;
        }

        const monthlySplitsMap = {};
        for (const split of splits) {
          const month = split.date.substring(0, 7);
          if (monthlySplitsMap[month]) {
            monthlySplitsMap[month].amount += split.amount;
          } else {
            monthlySplitsMap[month] = {
              date: month,
              amount: split.amount,
            };
          }
        }
        // total amount of all splits for a month:
        // {
        //   date: string, // "2021-04"
        //   amount: number // in cents
        // }[]
        const monthlySplits = Object.values(monthlySplitsMap);

        drawTagsGraph(svg, monthlySplits);

        drawMonthlyTagStatistics(monthlySplits);
      }

      function drawMonthlyTagStatistics(splits) {
        // total amount for each year:
        // {
        //   year: string, // "2018"
        //   amount: number, // in cents
        //   months: Set<string> // ["01", "02", …]
        // }[]
        const amountsByYear = Object.values(
          splits.reduce((amountsByYear, split) => {
            const year = split.date.substring(0, 4);
            const month = split.date.substring(5, 7);
            if (amountsByYear[year]) {
              amountsByYear[year].amount += split.amount;
              amountsByYear[year].months.add(month);
            } else {
              amountsByYear[year] = {
                year,
                amount: split.amount,
                months: new Set([month]),
              };
            }
            return amountsByYear;
          }, {})
        );

        const tableBody = document.querySelector(
          "table#monthly-averages > tbody"
        );

        // clear the table content
        tableBody.innerHTML = "";

        const monthlyTableRowTemplate =
          document.querySelector("#monthly-table-row");

        // add 1 row per year to the table
        for (const amountByYear of amountsByYear) {
          const monthlyAverage = Math.round(
            amountByYear.amount / CENTS_IN_ONE_CHF / amountByYear.months.size
          );

          const monthlyTableRowClone =
            monthlyTableRowTemplate.content.cloneNode(true);

          const cells = monthlyTableRowClone.querySelectorAll("td");
          cells[0].textContent = amountByYear.year;
          cells[1].textContent = monthlyAverage;

          tableBody.appendChild(monthlyTableRowClone);
        }
      }

      function drawTagsGraph(svg, splits) {
        if (!svg || splits.length < 1) {
          return;
        }

        const GRAPH_BAR_WIDTH_IN_PIXELS = 5;
        const CENTS_HEIGHT_IN_PIXELS = 0.01; // 1 CHF = 1 pixel
        const AXIS_TEXT_MARGIN_IN_PIXELS = 2;
        const AXIS_TEXT_SIZE_IN_PIXELS = 12; // SVG text size in CSS

        let xAxisLabels; // { label: string, index: number }[] where index is the index of the label in splits
        let yAxisResolutionInCHF; // a horizontal line will be drawn at each multiple of this y value
        let startDate = splits[0].date;
        if (startDate.length === 10) {
          // daily mode
          xAxisLabels = Object.values(
            splits.reduce((xAxisLabels, split, index) => {
              const label = split.date.substring(0, 7); // year + month
              if (!xAxisLabels[label]) {
                xAxisLabels[label] = {
                  label,
                  index,
                };
              }
              return xAxisLabels;
            }, {})
          );
          yAxisResolutionInCHF = 50;
        } else if (startDate.length === 7) {
          // monthly mode
          xAxisLabels = Object.values(
            splits.reduce((xAxisLabels, split, index) => {
              const label = split.date.substring(0, 4); // year
              if (!xAxisLabels[label]) {
                xAxisLabels[label] = {
                  label,
                  index,
                };
              }
              return xAxisLabels;
            }, {})
          );
          yAxisResolutionInCHF = 100;
        } else {
          return;
        }

        function dateToPixels(index) {
          return index * GRAPH_BAR_WIDTH_IN_PIXELS;
        }

        function amountToPixels(amount) {
          return amount * CENTS_HEIGHT_IN_PIXELS;
        }

        const maxAmount = splits.reduce((maxAmount, split) => {
          if (split.amount > maxAmount) {
            maxAmount = split.amount;
          }
          return maxAmount;
        }, 0);

        const svgWidth = splits.length * GRAPH_BAR_WIDTH_IN_PIXELS;
        const svgHeight =
          amountToPixels(maxAmount) +
          (AXIS_TEXT_SIZE_IN_PIXELS + AXIS_TEXT_MARGIN_IN_PIXELS);

        svg.setAttribute("width", svgWidth);
        svg.setAttribute("height", svgHeight);
        svg.style.width = svgWidth + "px";
        svg.style.height = svgHeight + "px";

        // clear previous x-axis labels
        svg.querySelectorAll("& > g.x-axis").forEach((g) => svg.removeChild(g));
        // draw x-axis labels
        for (let i = 0; i < xAxisLabels.length; i += 1) {
          const { index, label } = xAxisLabels[i];

          const g = svg.querySelector("defs > g.x-axis").cloneNode(true);

          const x = dateToPixels(index);

          const line = g.querySelector("line");
          line.setAttribute("x1", x);
          line.setAttribute("y1", amountToPixels(maxAmount));
          line.setAttribute("x2", x);
          line.setAttribute(
            "y2",
            amountToPixels(maxAmount) + AXIS_TEXT_MARGIN_IN_PIXELS
          );

          const text = g.querySelector("text");
          text.setAttribute("x", x);
          text.setAttribute(
            "y",
            amountToPixels(maxAmount) +
              AXIS_TEXT_SIZE_IN_PIXELS +
              AXIS_TEXT_MARGIN_IN_PIXELS
          );
          text.textContent = label;

          svg.appendChild(g);
        }

        // clear previous y-axis labels and lines
        svg.querySelectorAll("& > g.y-axis").forEach((g) => svg.removeChild(g));
        // draw y-axis labels and lines
        for (
          let i = 1;
          i < Math.ceil(maxAmount / (yAxisResolutionInCHF * CENTS_IN_ONE_CHF));
          i += 1
        ) {
          const g = svg.querySelector("defs > g.y-axis").cloneNode(true);

          const y = amountToPixels(
            maxAmount - i * (yAxisResolutionInCHF * CENTS_IN_ONE_CHF)
          );

          const line = g.querySelector("line");
          line.setAttribute("x1", 0);
          line.setAttribute("y1", y);
          line.setAttribute("x2", svgWidth);
          line.setAttribute("y2", y);

          const text = g.querySelector("text");
          text.setAttribute("x", 0);
          text.setAttribute("y", y - AXIS_TEXT_MARGIN_IN_PIXELS);
          text.textContent = i * yAxisResolutionInCHF;

          svg.appendChild(g);
        }

        // clear previous graph
        svg
          .querySelectorAll("& > rect")
          .forEach((rect) => svg.removeChild(rect));
        // draw graph, 1 <rect> per split
        for (let i = 0; i < splits.length; i += 1) {
          const split = splits[i];

          const x = dateToPixels(i);
          const y = amountToPixels(maxAmount - split.amount);
          const width = GRAPH_BAR_WIDTH_IN_PIXELS;
          const height = amountToPixels(split.amount);

          const rect = svg.querySelector("defs > rect").cloneNode(true);

          rect.setAttribute("x", x);
          rect.setAttribute("y", y);
          rect.setAttribute("width", width);
          rect.setAttribute("height", height);

          rect.querySelector("title").textContent =
            split.amount / CENTS_IN_ONE_CHF +
            (split.notes?.length ? " = " + split.notes.join(" + ") : "");

          svg.appendChild(rect);
        }
      }

      function readExistingData(file, onFileRead) {
        const fileReader = new FileReader();

        fileReader.addEventListener("load", (event) => {
          try {
            const existingData = JSON.parse(event.target.result);
            onFileRead(existingData);
          } catch (error) {
            console.error(error);
          }
        });

        fileReader.readAsText(file);
      }

      function readNewData(file, onFileRead) {
        const fileReader = new FileReader();

        fileReader.addEventListener("load", (event) => {
          try {
            const newData = csvToDebit(event.target.result);
            onFileRead(newData);
          } catch (error) {
            console.error(error);
          }
        });

        fileReader.readAsText(file);
      }

      function exportToJsonFile() {
        const debits = readAppState("debits");
        const filename = `debittaggr-${
          new Date().toISOString().split(".")[0]
        }.json`;
        const href = `data:text/json;charset=utf-8,${encodeURIComponent(
          JSON.stringify(debits, null, 2)
        )}`;
        const temporaryElement = document.createElement("a");
        temporaryElement.setAttribute("href", href);
        temporaryElement.setAttribute("download", filename);
        temporaryElement.click();
        temporaryElement.remove();
      }

      function csvToDebit(fileContents) {
        const delimiter = ";";
        const newLine = "\n";

        const rows = fileContents
          .slice(fileContents.indexOf(newLine) + 1)
          .split(newLine);

        return rows
          .map((row) => {
            const unescaped = row
              .replaceAll(
                /"""(.+?)""";/g,
                (match, p1) => p1.replaceAll(delimiter, " ") + delimiter
              )
              .replaceAll(/"(.+?)";/g, (match, p1) => p1 + delimiter);
            const values = unescaped.split(delimiter);
            if (values.length !== 15) {
              return null;
            }
            const amount = values[5]
              .replaceAll("'", "")
              .replaceAll(".", "")
              .replaceAll("-", "");
            if (amount === "") {
              return null;
            }
            return {
              amount,
              description: [values[10], values[11], values[12]].join(" "),
              date: values[0],
              currency: values[4],
              splits: [],
            };
          })
          .filter((row) => {
            return row !== null;
          });
      }

      function loadSplitIntoForm(debit, index, tags, split) {
        const splitTemplate = document.querySelector("#split");
        const splitClone = splitTemplate.content.cloneNode(true);

        splitClone
          .querySelector("fieldset")
          .setAttribute("id", `split-${index}`);

        let identifier = `split-${index}-amount`;

        splitClone
          .querySelector('label[for="split-n-amount"]')
          .setAttribute("for", identifier);

        const amountInput = splitClone.querySelector(
          'input[name="split-n-amount"]'
        );
        amountInput.setAttribute("id", identifier);
        amountInput.setAttribute("name", identifier);
        amountInput.value = split.amount;
        amountInput.addEventListener("input", (event) => {
          split.amount = event.target.value;
        });

        identifier = `split-${index}-notes`;

        splitClone
          .querySelector('label[for="split-n-notes"]')
          .setAttribute("for", identifier);

        const notesInput = splitClone.querySelector(
          'textarea[name="split-n-notes"]'
        );
        notesInput.setAttribute("id", identifier);
        notesInput.setAttribute("name", identifier);
        notesInput.value = split.notes;
        notesInput.addEventListener("input", (event) => {
          split.notes = event.target.value;
        });

        const tagsContainer = splitClone.querySelector("#split-n-tags");
        tagsContainer.setAttribute("id", `split-${index}-tags`);
        for (const tag of tags) {
          const tagTemplate = document.querySelector("#split-tag");
          const tagClone = tagTemplate.content.cloneNode(true);

          identifier = `split-${index}-${tag}`;

          const tagCheckbox = tagClone.querySelector("input");
          tagCheckbox.setAttribute("id", identifier);
          tagCheckbox.setAttribute("name", identifier);
          tagCheckbox.setAttribute("data-tag", tag);
          tagCheckbox.checked = split.tags.includes(tag);
          tagCheckbox.addEventListener("input", (event) => {
            const { tag } = event.target.dataset;
            if (event.target.checked) {
              split.tags.push(tag);
            } else {
              split.tags = split.tags.filter((splitTag) => splitTag !== tag);
            }
          });

          const tagLabel = tagClone.querySelector("label");
          tagLabel.setAttribute("for", identifier);
          tagLabel.textContent = tag;

          tagsContainer.appendChild(tagClone);
        }

        const newTagsInput = tagsContainer.querySelector(
          'input[name="split-n-new-tags"]'
        );
        newTagsInput.setAttribute("name", `split-${index}-new-tags`);
        newTagsInput.addEventListener("blur", (event) => {
          const newTags = event.target.value.toUpperCase().split(" ");
          for (const newTag of newTags) {
            if (!split.tags.includes(newTag)) {
              split.tags.push(newTag);
            }
            if (!tags.has(newTag)) {
              tags.add(newTag);
              updateAppState("tags", tags);
            }
          }
        });

        splitClone.querySelector("button").onclick = () => {
          debit.splits.splice(index, 1);
          loadSplitsIntoForm(debit, tags);
        };

        document.querySelector("#splits").appendChild(splitClone);
      }

      function loadSplitsIntoForm(debit, tags) {
        document.querySelector("#splits").innerHTML = "";

        if (debit.splits.length === 0) {
          addSplit();
        } else {
          for (let i = 0; i < debit.splits.length; i += 1) {
            loadSplitIntoForm(debit, i, tags, debit.splits[i]);
          }
        }
      }

      function loadDebitIntoForm(debit, tags) {
        document.querySelector('textarea[name="description"]').value =
          debit.description;
        document.querySelector('input[name="amount"]').value = debit.amount;
        document.querySelector('input[name="currency"]').value = debit.currency;
        document.querySelector('input[name="date"]').value = debit.date;

        loadSplitsIntoForm(debit, tags);
      }

      function loadDebitAtIndex(offset) {
        const debits = readAppState("debits");
        const tags = readAppState("tags");
        const currentIndex = readAppState("currentIndex");
        const index = (currentIndex + offset) % debits.length;

        updateAppState("currentIndex", index);

        loadDebitIntoForm(debits[index], tags);
      }

      function load(debits) {
        if (debits.length === 0) {
          document.querySelector("#debit").style.display = "none";
          document.querySelector("#statistics").style.display = "none";
          document.querySelector("#by-tags").style.display = "none";
          return;
        }
        document.querySelector("#debit").style.display = "flex";
        document.querySelector("#statistics").style.display = "flex";
        document.querySelector("#by-tags").style.display = "flex";

        const sortedDebits = debits.sort(sortByAscendingDate);

        let index = sortedDebits.findIndex(
          (debit) => debit.splits.length === 0
        );
        if (index === -1) {
          index = 0;
        }

        updateAppState("currentIndex", index);

        const tags = readAppState("tags");

        loadDebitIntoForm(debits[index], tags);
      }

      function addSplit() {
        const debits = readAppState("debits");
        const index = readAppState("currentIndex");
        const tags = readAppState("tags");

        const debit = debits[index];

        const split = {
          amount: String(
            debit.amount -
              debit.splits.reduce((splitAmount, split) => {
                splitAmount += Number(split.amount);
                return splitAmount;
              }, 0)
          ),
          notes: "",
          tags: [],
        };

        debit.splits.push(split);

        loadSplitIntoForm(debit, debit.splits.length - 1, tags, split);
      }

      const existingDataFileSelector = document.querySelector(
        'input[name="existing-data"]'
      );
      existingDataFileSelector.addEventListener("change", (event) => {
        readExistingData(event.target.files[0], (data) => {
          const debits = [...readAppState("debits"), ...data];
          updateAppState("debits", debits);
          load(debits);
        });
      });

      const newDataFileSelector = document.querySelector(
        'input[name="new-data"]'
      );
      newDataFileSelector.addEventListener("change", (event) => {
        readNewData(event.target.files[0], (data) => {
          const debits = [...readAppState("debits"), ...data];
          updateAppState("debits", debits);
          load(debits);
        });
      });

      load(readAppState("debits"));
    </script>
  </body>
</html>
